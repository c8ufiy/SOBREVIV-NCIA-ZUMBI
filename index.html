<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Jogo 3D de sobrevivência de zumbi">
  <meta name="theme-color" content="#0a0a0a">
  <title>UNDEAD PROTOCOL - 3D Survival</title>
  <link rel="manifest" href="/manifest.json">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --neon-green: #00ff41;
      --neon-red: #ff0051;
      --neon-cyan: #00f0ff;
      --dark-bg: #0a0a0a;
      --grid-color: #1a1a1a;
    }
    
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      position: fixed;
      touch-action: none;
      background: var(--dark-bg);
      font-family: 'Rajdhani', sans-serif;
    }
    
    #root {
      width: 100%;
      height: 100%;
      position: relative;
    }
    
    .game-canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    
    .scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: linear-gradient(
        transparent 50%,
        rgba(0, 255, 65, 0.02) 50%
      );
      background-size: 100% 4px;
      z-index: 100;
      animation: scanline 8s linear infinite;
    }
    
    @keyframes scanline {
      0% { transform: translateY(0); }
      100% { transform: translateY(4px); }
    }
    
    .hud {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      z-index: 50;
      font-family: 'Orbitron', monospace;
      pointer-events: none;
    }
    
    .hud-section {
      background: rgba(10, 10, 10, 0.85);
      border: 2px solid var(--neon-green);
      padding: 15px 20px;
      border-radius: 4px;
      box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
      backdrop-filter: blur(10px);
    }
    
    .hud-title {
      font-size: 10px;
      letter-spacing: 3px;
      color: var(--neon-green);
      margin-bottom: 8px;
      opacity: 0.7;
    }
    
    .hud-value {
      font-size: 28px;
      font-weight: 900;
      color: white;
      text-shadow: 0 0 10px var(--neon-green);
    }
    
    .health-bar {
      width: 200px;
      height: 8px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--neon-green);
      margin-top: 8px;
      position: relative;
      overflow: hidden;
    }
    
    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--neon-red), var(--neon-green));
      transition: width 0.3s;
      box-shadow: 0 0 10px currentColor;
    }
    
    .crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 40px;
      pointer-events: none;
      z-index: 60;
    }
    
    .crosshair::before,
    .crosshair::after {
      content: '';
      position: absolute;
      background: var(--neon-cyan);
      box-shadow: 0 0 10px var(--neon-cyan);
    }
    
    .crosshair::before {
      top: 50%;
      left: 0;
      width: 100%;
      height: 2px;
      transform: translateY(-50%);
    }
    
    .crosshair::after {
      left: 50%;
      top: 0;
      height: 100%;
      width: 2px;
      transform: translateX(-50%);
    }
    
    .crosshair-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 4px;
      height: 4px;
      background: var(--neon-red);
      border-radius: 50%;
      box-shadow: 0 0 10px var(--neon-red);
      animation: pulse 1s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      50% { opacity: 0.5; transform: translate(-50%, -50%) scale(1.5); }
    }
    
    .menu-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      overflow: hidden;
    }
    
    .menu-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        repeating-linear-gradient(
          0deg,
          transparent,
          transparent 2px,
          rgba(0, 255, 65, 0.03) 2px,
          rgba(0, 255, 65, 0.03) 4px
        );
      animation: bgScroll 20s linear infinite;
    }
    
    @keyframes bgScroll {
      0% { transform: translateY(0); }
      100% { transform: translateY(40px); }
    }
    
    .menu-content {
      position: relative;
      z-index: 1;
      text-align: center;
      max-width: 600px;
      padding: 40px;
    }
    
    .game-title {
      font-family: 'Orbitron', monospace;
      font-size: 72px;
      font-weight: 900;
      color: var(--neon-green);
      text-shadow: 
        0 0 20px var(--neon-green),
        0 0 40px var(--neon-green),
        0 0 60px rgba(0, 255, 65, 0.5);
      letter-spacing: 8px;
      margin-bottom: 10px;
      animation: titleGlow 2s ease-in-out infinite;
    }
    
    @keyframes titleGlow {
      0%, 100% { text-shadow: 0 0 20px var(--neon-green), 0 0 40px var(--neon-green); }
      50% { text-shadow: 0 0 30px var(--neon-green), 0 0 60px var(--neon-green), 0 0 80px rgba(0, 255, 65, 0.7); }
    }
    
    .game-subtitle {
      font-family: 'Rajdhani', sans-serif;
      font-size: 18px;
      color: var(--neon-cyan);
      letter-spacing: 6px;
      margin-bottom: 50px;
      text-shadow: 0 0 10px var(--neon-cyan);
    }
    
    .btn-start {
      font-family: 'Orbitron', monospace;
      font-size: 24px;
      font-weight: 700;
      padding: 20px 60px;
      background: transparent;
      color: var(--neon-green);
      border: 3px solid var(--neon-green);
      cursor: pointer;
      letter-spacing: 4px;
      transition: all 0.3s;
      box-shadow: 
        0 0 20px rgba(0, 255, 65, 0.3),
        inset 0 0 20px rgba(0, 255, 65, 0.1);
      position: relative;
      overflow: hidden;
    }
    
    .btn-start::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.3), transparent);
      transition: left 0.5s;
    }
    
    .btn-start:hover::before {
      left: 100%;
    }
    
    .btn-start:hover {
      background: var(--neon-green);
      color: black;
      box-shadow: 
        0 0 40px var(--neon-green),
        inset 0 0 40px rgba(0, 255, 65, 0.5);
    }
    
    .controls-info {
      margin-top: 40px;
      padding: 20px;
      background: rgba(0, 255, 65, 0.05);
      border: 1px solid rgba(0, 255, 65, 0.2);
      font-family: 'Rajdhani', sans-serif;
    }
    
    .controls-title {
      font-family: 'Orbitron', monospace;
      font-size: 14px;
      color: var(--neon-green);
      letter-spacing: 3px;
      margin-bottom: 15px;
    }
    
    .control-item {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      color: rgba(255, 255, 255, 0.7);
      font-size: 16px;
    }
    
    .control-key {
      color: var(--neon-cyan);
      font-weight: 600;
      text-shadow: 0 0 5px var(--neon-cyan);
    }
    
    .wave-alert {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Orbitron', monospace;
      font-size: 48px;
      font-weight: 900;
      color: var(--neon-red);
      text-shadow: 0 0 30px var(--neon-red);
      z-index: 150;
      pointer-events: none;
      animation: waveAlert 2s ease-out forwards;
      opacity: 0;
    }
    
    @keyframes waveAlert {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
    }
    
    .special-indicator {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 60;
      pointer-events: none;
    }
    
    .special-charges {
      display: flex;
      gap: 10px;
    }
    
    .charge {
      width: 40px;
      height: 40px;
      border: 2px solid var(--neon-cyan);
      background: rgba(0, 240, 255, 0.1);
      position: relative;
      clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
    }
    
    .charge.active {
      background: var(--neon-cyan);
      box-shadow: 0 0 20px var(--neon-cyan);
      animation: chargeGlow 1s infinite;
    }
    
    @keyframes chargeGlow {
      0%, 100% { box-shadow: 0 0 20px var(--neon-cyan); }
      50% { box-shadow: 0 0 40px var(--neon-cyan), 0 0 60px var(--neon-cyan); }
    }
    
    @media (max-width: 768px) {
      .game-title { font-size: 36px; }
      .game-subtitle { font-size: 14px; }
      .btn-start { font-size: 18px; padding: 15px 40px; }
      .hud-section { padding: 10px 15px; }
      .hud-value { font-size: 20px; }
      .health-bar { width: 120px; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <div class="scanlines"></div>
  
  <script type="module">
    import React from 'https://esm.sh/react@18.2.0';
    import ReactDOM from 'https://esm.sh/react-dom@18.2.0/client';

    const { useState, useEffect, useRef } = React;

    function ZombieGame3D() {
      const containerRef = useRef(null);
      const [gameState, setGameState] = useState('menu');
      const [health, setHealth] = useState(100);
      const [ammo, setAmmo] = useState(30);
      const [score, setScore] = useState(0);
      const [wave, setWave] = useState(1);
      const [specialCharges, setSpecialCharges] = useState(3);
      const [showWaveAlert, setShowWaveAlert] = useState(false);
      
      const gameRef = useRef({
        scene: null,
        camera: null,
        renderer: null,
        player: null,
        zombies: [],
        bullets: [],
        floor: null,
        mouseX: 0,
        mouseY: 0,
        keys: {},
        lastShot: 0,
        animationFrame: null
      });

      useEffect(() => {
        if (gameState === 'playing' && containerRef.current) {
          initGame();
        }
        
        return () => {
          if (gameRef.current.animationFrame) {
            cancelAnimationFrame(gameRef.current.animationFrame);
          }
          if (gameRef.current.renderer) {
            gameRef.current.renderer.dispose();
          }
        };
      }, [gameState]);

      const initGame = () => {
        const container = containerRef.current;
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a0a, 10, 100);
        
        const camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 15, 15);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x00ff41, 0.2);
        scene.add(ambientLight);
        
        const dirLight = new THREE.DirectionalLight(0x00f0ff, 0.8);
        dirLight.position.set(5, 20, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);
        
        // Floor with grid
        const floorGeometry = new THREE.PlaneGeometry(100, 100, 50, 50);
        const floorMaterial = new THREE.MeshStandardMaterial({
          color: 0x0a0a0a,
          wireframe: true,
          emissive: 0x00ff41,
          emissiveIntensity: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // Player
        const playerGroup = new THREE.Group();
        
        const bodyGeometry = new THREE.BoxGeometry(1, 2, 0.5);
        const bodyMaterial = new THREE.MeshStandardMaterial({
          color: 0x0066ff,
          emissive: 0x0033ff,
          emissiveIntensity: 0.3
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1;
        body.castShadow = true;
        playerGroup.add(body);
        
        const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
        const headMaterial = new THREE.MeshStandardMaterial({
          color: 0xffd700,
          emissive: 0xffaa00,
          emissiveIntensity: 0.3
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 2.4;
        head.castShadow = true;
        playerGroup.add(head);
        
        const gunGeometry = new THREE.BoxGeometry(0.2, 0.2, 1.5);
        const gunMaterial = new THREE.MeshStandardMaterial({
          color: 0x222222,
          metalness: 0.8,
          roughness: 0.2
        });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.position.set(0.5, 1.5, -0.8);
        gun.castShadow = true;
        playerGroup.add(gun);
        
        scene.add(playerGroup);
        
        gameRef.current = {
          ...gameRef.current,
          scene,
          camera,
          renderer,
          player: playerGroup,
          floor
        };
        
        // Input handlers
        const handleKeyDown = (e) => {
          gameRef.current.keys[e.key.toLowerCase()] = true;
          if (e.key === ' ') {
            e.preventDefault();
            useSpecial();
          }
        };
        
        const handleKeyUp = (e) => {
          gameRef.current.keys[e.key.toLowerCase()] = false;
        };
        
        const handleMouseMove = (e) => {
          gameRef.current.mouseX = (e.clientX / window.innerWidth) * 2 - 1;
          gameRef.current.mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
        };
        
        const handleClick = () => {
          shoot();
        };
        
        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('click', handleClick);
        
        spawnWave(1);
        animate();
        
        return () => {
          window.removeEventListener('keydown', handleKeyDown);
          window.removeEventListener('keyup', handleKeyUp);
          window.removeEventListener('mousemove', handleMouseMove);
          window.removeEventListener('click', handleClick);
        };
      };

      const spawnWave = (waveNum) => {
        setShowWaveAlert(true);
        setTimeout(() => setShowWaveAlert(false), 2000);
        
        const zombieCount = 5 + waveNum * 2;
        
        for (let i = 0; i < zombieCount; i++) {
          setTimeout(() => {
            const angle = Math.random() * Math.PI * 2;
            const distance = 30 + Math.random() * 20;
            const x = Math.cos(angle) * distance;
            const z = Math.sin(angle) * distance;
            
            const zombieGroup = new THREE.Group();
            zombieGroup.position.set(x, 0, z);
            
            const zombieBody = new THREE.BoxGeometry(0.8, 1.8, 0.4);
            const zombieMaterial = new THREE.MeshStandardMaterial({
              color: 0x228B22,
              emissive: 0xff0000,
              emissiveIntensity: 0.2
            });
            const body = new THREE.Mesh(zombieBody, zombieMaterial);
            body.position.y = 0.9;
            body.castShadow = true;
            zombieGroup.add(body);
            
            const zombieHead = new THREE.SphereGeometry(0.35, 16, 16);
            const head = new THREE.Mesh(zombieHead, zombieMaterial);
            head.position.y = 2;
            head.castShadow = true;
            zombieGroup.add(head);
            
            gameRef.current.scene.add(zombieGroup);
            gameRef.current.zombies.push({
              mesh: zombieGroup,
              health: 2 + Math.floor(waveNum / 2),
              maxHealth: 2 + Math.floor(waveNum / 2),
              speed: 0.05 + waveNum * 0.01
            });
          }, i * 300);
        }
      };

      const shoot = () => {
        const now = Date.now();
        if (now - gameRef.current.lastShot < 200 || ammo <= 0) return;
        
        gameRef.current.lastShot = now;
        setAmmo(prev => prev - 1);
        
        const player = gameRef.current.player;
        const direction = new THREE.Vector3(
          gameRef.current.mouseX,
          0,
          -gameRef.current.mouseY
        ).normalize();
        
        const bulletGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const bulletMaterial = new THREE.MeshStandardMaterial({
          color: 0xffff00,
          emissive: 0xffff00,
          emissiveIntensity: 1
        });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
        bullet.position.copy(player.position);
        bullet.position.y = 1.5;
        
        gameRef.current.scene.add(bullet);
        gameRef.current.bullets.push({
          mesh: bullet,
          velocity: direction.multiplyScalar(0.8)
        });
        
        // Add point light to bullet
        const light = new THREE.PointLight(0xffff00, 1, 5);
        bullet.add(light);
      };

      const useSpecial = () => {
        if (specialCharges <= 0) return;
        
        setSpecialCharges(prev => prev - 1);
        
        // Explosion effect
        const explosionGeometry = new THREE.SphereGeometry(15, 32, 32);
        const explosionMaterial = new THREE.MeshBasicMaterial({
          color: 0x00ffff,
          transparent: true,
          opacity: 0.5,
          wireframe: true
        });
        const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
        explosion.position.copy(gameRef.current.player.position);
        gameRef.current.scene.add(explosion);
        
        setTimeout(() => {
          gameRef.current.scene.remove(explosion);
        }, 500);
        
        // Damage zombies
        gameRef.current.zombies.forEach(zombie => {
          const distance = zombie.mesh.position.distanceTo(gameRef.current.player.position);
          if (distance < 15) {
            zombie.health -= 3;
          }
        });
        
        // Remove dead zombies
        gameRef.current.zombies = gameRef.current.zombies.filter(zombie => {
          if (zombie.health <= 0) {
            gameRef.current.scene.remove(zombie.mesh);
            setScore(prev => prev + 10);
            return false;
          }
          return true;
        });
      };

      const animate = () => {
        const game = gameRef.current;
        
        // Player movement
        const moveSpeed = 0.2;
        if (game.keys['w']) game.player.position.z -= moveSpeed;
        if (game.keys['s']) game.player.position.z += moveSpeed;
        if (game.keys['a']) game.player.position.x -= moveSpeed;
        if (game.keys['d']) game.player.position.x += moveSpeed;
        
        // Clamp player position
        game.player.position.x = Math.max(-40, Math.min(40, game.player.position.x));
        game.player.position.z = Math.max(-40, Math.min(40, game.player.position.z));
        
        // Player rotation
        const targetRotation = Math.atan2(game.mouseX, -game.mouseY);
        game.player.rotation.y = targetRotation;
        
        // Camera follow
        game.camera.position.x = game.player.position.x;
        game.camera.position.z = game.player.position.z + 15;
        game.camera.lookAt(game.player.position);
        
        // Update bullets
        game.bullets = game.bullets.filter(bullet => {
          bullet.mesh.position.add(bullet.velocity);
          
          const distance = bullet.mesh.position.length();
          if (distance > 50) {
            game.scene.remove(bullet.mesh);
            return false;
          }
          
          // Check collision with zombies
          for (let i = game.zombies.length - 1; i >= 0; i--) {
            const zombie = game.zombies[i];
            const dist = bullet.mesh.position.distanceTo(zombie.mesh.position);
            
            if (dist < 1) {
              zombie.health--;
              game.scene.remove(bullet.mesh);
              
              if (zombie.health <= 0) {
                game.scene.remove(zombie.mesh);
                game.zombies.splice(i, 1);
                setScore(prev => prev + 10);
                
                if (Math.random() < 0.3) {
                  setAmmo(prev => prev + 5);
                }
              }
              
              return false;
            }
          }
          
          return true;
        });
        
        // Update zombies
        game.zombies.forEach(zombie => {
          const direction = new THREE.Vector3()
            .subVectors(game.player.position, zombie.mesh.position)
            .normalize();
          
          zombie.mesh.position.add(direction.multiplyScalar(zombie.speed));
          zombie.mesh.lookAt(game.player.position);
          
          // Check collision with player
          const dist = zombie.mesh.position.distanceTo(game.player.position);
          if (dist < 1.5) {
            setHealth(prev => {
              const newHealth = Math.max(0, prev - 0.3);
              if (newHealth <= 0) {
                setGameState('gameOver');
              }
              return newHealth;
            });
          }
        });
        
        // Check wave completion
        if (game.zombies.length === 0 && gameState === 'playing') {
          setWave(prev => {
            const newWave = prev + 1;
            spawnWave(newWave);
            setAmmo(prevAmmo => prevAmmo + 15);
            setSpecialCharges(prevCharges => Math.min(5, prevCharges + 1));
            return newWave;
          });
        }
        
        game.renderer.render(game.scene, game.camera);
        game.animationFrame = requestAnimationFrame(animate);
      };

      return React.createElement('div', { style: { width: '100%', height: '100%' } },
        gameState === 'menu' && React.createElement('div', { className: 'menu-container' },
          React.createElement('div', { className: 'menu-bg' }),
          React.createElement('div', { className: 'menu-content' },
            React.createElement('h1', { className: 'game-title' }, 'UNDEAD'),
            React.createElement('div', { className: 'game-subtitle' }, 'PROTOCOL'),
            React.createElement('button', {
              className: 'btn-start',
              onClick: () => {
                setHealth(100);
                setAmmo(30);
                setScore(0);
                setWave(1);
                setSpecialCharges(3);
                setGameState('playing');
              }
            }, 'INICIAR'),
            React.createElement('div', { className: 'controls-info' },
              React.createElement('div', { className: 'controls-title' }, '[ CONTROLES ]'),
              React.createElement('div', { className: 'control-item' },
                React.createElement('span', {}, 'MOVIMENTO'),
                React.createElement('span', { className: 'control-key' }, 'WASD')
              ),
              React.createElement('div', { className: 'control-item' },
                React.createElement('span', {}, 'MIRAR'),
                React.createElement('span', { className: 'control-key' }, 'MOUSE')
              ),
              React.createElement('div', { className: 'control-item' },
                React.createElement('span', {}, 'ATIRAR'),
                React.createElement('span', { className: 'control-key' }, 'CLICK')
              ),
              React.createElement('div', { className: 'control-item' },
                React.createElement('span', {}, 'ESPECIAL'),
                React.createElement('span', { className: 'control-key' }, 'ESPAÇO')
              )
            )
          )
        ),
        
        gameState === 'playing' && React.createElement('div', {},
          React.createElement('div', { ref: containerRef, className: 'game-canvas' }),
          React.createElement('div', { className: 'hud' },
            React.createElement('div', { className: 'hud-section' },
              React.createElement('div', { className: 'hud-title' }, 'VIDA'),
              React.createElement('div', { className: 'hud-value' }, Math.round(health) + '%'),
              React.createElement('div', { className: 'health-bar' },
                React.createElement('div', {
                  className: 'health-fill',
                  style: { width: health + '%' }
                })
              )
            ),
            React.createElement('div', { style: { display: 'flex', gap: '15px' } },
              React.createElement('div', { className: 'hud-section' },
                React.createElement('div', { className: 'hud-title' }, 'MUNIÇÃO'),
                React.createElement('div', { className: 'hud-value' }, ammo)
              ),
              React.createElement('div', { className: 'hud-section' },
                React.createElement('div', { className: 'hud-title' }, 'ONDA'),
                React.createElement('div', { className: 'hud-value' }, wave)
              ),
              React.createElement('div', { className: 'hud-section' },
                React.createElement('div', { className: 'hud-title' }, 'SCORE'),
                React.createElement('div', { className: 'hud-value' }, score)
              )
            )
          ),
          React.createElement('div', { className: 'crosshair' },
            React.createElement('div', { className: 'crosshair-center' })
          ),
          React.createElement('div', { className: 'special-indicator' },
            React.createElement('div', { className: 'special-charges' },
              [...Array(5)].map((_, i) =>
                React.createElement('div', {
                  key: i,
                  className: 'charge' + (i < specialCharges ? ' active' : '')
                })
              )
            )
          ),
          showWaveAlert && React.createElement('div', { className: 'wave-alert' }, 
            `ONDA ${wave}`
          )
        ),
        
        gameState === 'gameOver' && React.createElement('div', { className: 'menu-container' },
          React.createElement('div', { className: 'menu-bg' }),
          React.createElement('div', { className: 'menu-content' },
            React.createElement('h1', { 
              className: 'game-title',
              style: { color: 'var(--neon-red)' }
            }, 'ELIMINADO'),
            React.createElement('div', { 
              className: 'game-subtitle',
              style: { marginBottom: '30px' }
            }, 'MISSÃO FALHOU'),
            React.createElement('div', { 
              style: { 
                fontSize: '48px', 
                color: 'var(--neon-green)',
                fontFamily: 'Orbitron',
                marginBottom: '40px',
                textShadow: '0 0 20px var(--neon-green)'
              }
            }, score + ' PONTOS'),
            React.createElement('button', {
              className: 'btn-start',
              style: { borderColor: 'var(--neon-red)', color: 'var(--neon-red)' },
              onClick: () => setGameState('menu')
            }, 'MENU')
          )
        )
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(ZombieGame3D));
  </script>
</body>
</html>
