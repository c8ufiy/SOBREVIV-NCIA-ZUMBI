<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="description" content="Jogo de sobrevivÃªncia de zumbi">
  <meta name="theme-color" content="#991b1b">
  <title>SobrevivÃªncia Zumbi - PWA Game</title>
  <link rel="manifest" href="/manifest.json">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      position: fixed;
      touch-action: none;
    }
    
    #root {
      width: 100%;
      height: 100%;
    }
    
    canvas {
      display: block;
      touch-action: none;
    }
    
    .game-container {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    @media (max-width: 768px) {
      .desktop-only {
        display: none !important;
      }
    }
    
    @media (orientation: portrait) and (max-width: 768px) {
      .landscape-warning {
        display: flex !important;
      }
      .game-content {
        display: none !important;
      }
    }
    
    .landscape-warning {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom right, #1a1a1a, #991b1b, #1a1a1a);
      color: white;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 20px;
      text-align: center;
    }
    
    .rotate-icon {
      font-size: 80px;
      animation: rotate 2s infinite;
    }
    
    @keyframes rotate {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <!-- Landscape warning for mobile portrait -->
  <div class="landscape-warning">
    <div class="rotate-icon">ðŸ“±</div>
    <h1 style="font-size: 32px; font-weight: bold; margin: 20px 0;">Gire seu dispositivo</h1>
    <p style="font-size: 18px; opacity: 0.8;">Este jogo funciona melhor na horizontal</p>
  </div>
  
  <script type="module">
    import React from 'https://esm.sh/react@18.2.0';
    import ReactDOM from 'https://esm.sh/react-dom@18.2.0/client';
    import * as LucideReact from 'https://esm.sh/lucide-react@0.263.1';

    const { useState, useEffect, useRef } = React;
    const { Skull, Heart, Target, Award, PlayCircle, RotateCcw, Volume2, VolumeX, Zap } = LucideReact;

    function ZombieSurvivalGame() {
      const canvasRef = useRef(null);
      const [gameState, setGameState] = useState('menu');
      const [score, setScore] = useState(0);
      const [health, setHealth] = useState(100);
      const [ammo, setAmmo] = useState(30);
      const [wave, setWave] = useState(1);
      const [highScore, setHighScore] = useState(0);
      const [soundEnabled, setSoundEnabled] = useState(true);
      const [specialCharges, setSpecialCharges] = useState(3);
      const [canvasSize, setCanvasSize] = useState({ width: 800, height: 600 });
      
      const audioContextRef = useRef(null);
      const mouseDownRef = useRef(false);
      
      const gameRef = useRef({
        player: { x: 400, y: 300, angle: 0, speed: 3 },
        zombies: [],
        bullets: [],
        particles: [],
        keys: {},
        mousePos: { x: 0, y: 0 },
        lastShot: 0,
        animationFrame: null
      });

      // Handle responsive canvas sizing
      useEffect(() => {
        const updateCanvasSize = () => {
          const maxWidth = window.innerWidth - 40;
          const maxHeight = window.innerHeight - 200;
          const aspectRatio = 4 / 3;
          
          let width = maxWidth;
          let height = width / aspectRatio;
          
          if (height > maxHeight) {
            height = maxHeight;
            width = height * aspectRatio;
          }
          
          // Ensure minimum size
          width = Math.max(320, Math.min(800, width));
          height = Math.max(240, Math.min(600, height));
          
          setCanvasSize({ width, height });
          
          // Update game world if playing
          if (gameRef.current.player) {
            const scaleX = width / 800;
            const scaleY = height / 600;
            gameRef.current.player.x = 400 * scaleX;
            gameRef.current.player.y = 300 * scaleY;
          }
        };
        
        updateCanvasSize();
        window.addEventListener('resize', updateCanvasSize);
        window.addEventListener('orientationchange', updateCanvasSize);
        
        return () => {
          window.removeEventListener('resize', updateCanvasSize);
          window.removeEventListener('orientationchange', updateCanvasSize);
        };
      }, []);

      useEffect(() => {
        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();
      }, []);

      const playSound = (type) => {
        if (!soundEnabled || !audioContextRef.current) return;
        
        const ctx = audioContextRef.current;
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        switch(type) {
          case 'shoot':
            oscillator.frequency.setValueAtTime(300, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.1);
            break;
            
          case 'hit':
            oscillator.frequency.setValueAtTime(150, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.15);
            gainNode.gain.setValueAtTime(0.4, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
            oscillator.type = 'sawtooth';
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.15);
            break;
            
          case 'kill':
            oscillator.frequency.setValueAtTime(200, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.3);
            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            oscillator.type = 'square';
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.3);
            break;
            
          case 'damage':
            oscillator.frequency.setValueAtTime(100, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(30, ctx.currentTime + 0.4);
            gainNode.gain.setValueAtTime(0.5, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.4);
            oscillator.type = 'sawtooth';
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.4);
            break;
            
          case 'reload':
            oscillator.frequency.setValueAtTime(400, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(600, ctx.currentTime + 0.2);
            gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.2);
            break;
            
          case 'wave':
            oscillator.frequency.setValueAtTime(600, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.5);
            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.5);
            oscillator.type = 'sine';
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.5);
            break;
            
          case 'gameOver':
            oscillator.frequency.setValueAtTime(400, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 1);
            gainNode.gain.setValueAtTime(0.4, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 1);
            oscillator.type = 'sawtooth';
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 1);
            break;
            
          case 'special':
            for (let i = 0; i < 3; i++) {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.connect(gain);
              gain.connect(ctx.destination);
              
              osc.frequency.setValueAtTime(800 - i * 200, ctx.currentTime + i * 0.1);
              osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.3 + i * 0.1);
              gain.gain.setValueAtTime(0.5, ctx.currentTime + i * 0.1);
              gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3 + i * 0.1);
              osc.type = 'square';
              osc.start(ctx.currentTime + i * 0.1);
              osc.stop(ctx.currentTime + 0.3 + i * 0.1);
            }
            break;
        }
      };

      useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const game = gameRef.current;

        const handleKeyDown = (e) => {
          game.keys[e.key.toLowerCase()] = true;
          
          if (e.key === ' ' && gameState === 'playing') {
            e.preventDefault();
            useSpecial();
          }
        };

        const handleKeyUp = (e) => {
          game.keys[e.key.toLowerCase()] = false;
        };

        const handleMouseMove = (e) => {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvasSize.width / rect.width;
          const scaleY = canvasSize.height / rect.height;
          
          const clientX = e.clientX || (e.touches && e.touches[0]?.clientX);
          const clientY = e.clientY || (e.touches && e.touches[0]?.clientY);
          
          if (clientX !== undefined && clientY !== undefined) {
            game.mousePos = {
              x: (clientX - rect.left) * scaleX,
              y: (clientY - rect.top) * scaleY
            };
          }
        };

        const handleMouseDown = (e) => {
          if (gameState !== 'playing') return;
          e.preventDefault();
          mouseDownRef.current = true;
          handleMouseMove(e);
          shoot();
        };

        const handleMouseUp = () => {
          mouseDownRef.current = false;
        };

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('touchend', handleMouseUp);
        window.addEventListener('mouseup', handleMouseUp);
        window.addEventListener('touchend', handleMouseUp);

        return () => {
          window.removeEventListener('keydown', handleKeyDown);
          window.removeEventListener('keyup', handleKeyUp);
          canvas.removeEventListener('mousemove', handleMouseMove);
          canvas.removeEventListener('touchmove', handleMouseMove);
          canvas.removeEventListener('mousedown', handleMouseDown);
          canvas.removeEventListener('touchstart', handleMouseDown);
          canvas.removeEventListener('mouseup', handleMouseUp);
          canvas.removeEventListener('touchend', handleMouseUp);
          window.removeEventListener('mouseup', handleMouseUp);
          window.removeEventListener('touchend', handleMouseUp);
        };
      }, [gameState, canvasSize]);

      useEffect(() => {
        if (gameState === 'playing') {
          startGame();
        } else if (gameState === 'menu' || gameState === 'gameOver') {
          if (gameRef.current.animationFrame) {
            cancelAnimationFrame(gameRef.current.animationFrame);
          }
        }
      }, [gameState]);

      const startGame = () => {
        const game = gameRef.current;
        game.player = { 
          x: canvasSize.width / 2, 
          y: canvasSize.height / 2, 
          angle: 0, 
          speed: 3 
        };
        game.zombies = [];
        game.bullets = [];
        game.particles = [];
        
        setScore(0);
        setHealth(100);
        setAmmo(30);
        setWave(1);
        setSpecialCharges(3);
        
        spawnWave(1);
        gameLoop();
      };

      const spawnWave = (waveNum) => {
        const game = gameRef.current;
        const zombieCount = 5 + waveNum * 3;
        
        for (let i = 0; i < zombieCount; i++) {
          setTimeout(() => {
            const side = Math.floor(Math.random() * 4);
            let x, y;
            
            switch(side) {
              case 0: x = Math.random() * canvasSize.width; y = -20; break;
              case 1: x = canvasSize.width + 20; y = Math.random() * canvasSize.height; break;
              case 2: x = Math.random() * canvasSize.width; y = canvasSize.height + 20; break;
              case 3: x = -20; y = Math.random() * canvasSize.height; break;
            }
            
            game.zombies.push({
              x, y,
              speed: 0.5 + waveNum * 0.1,
              health: 2 + Math.floor(waveNum / 3),
              maxHealth: 2 + Math.floor(waveNum / 3)
            });
          }, i * 500);
        }
      };

      const shoot = () => {
        const game = gameRef.current;
        const now = Date.now();
        
        if (now - game.lastShot < 250 || ammo <= 0) return;
        
        game.lastShot = now;
        setAmmo(prev => prev - 1);
        playSound('shoot');
        
        const angle = Math.atan2(
          game.mousePos.y - game.player.y,
          game.mousePos.x - game.player.x
        );
        
        game.bullets.push({
          x: game.player.x,
          y: game.player.y,
          vx: Math.cos(angle) * 8,
          vy: Math.sin(angle) * 8
        });
      };

      const useSpecial = () => {
        if (specialCharges <= 0) return;
        
        const game = gameRef.current;
        setSpecialCharges(prev => prev - 1);
        playSound('special');
        
        createParticles(game.player.x, game.player.y, '#fbbf24', 30);
        
        game.zombies.forEach(zombie => {
          const dx = zombie.x - game.player.x;
          const dy = zombie.y - game.player.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 300) {
            zombie.health -= 3;
            createParticles(zombie.x, zombie.y, '#ef4444', 5);
          }
        });
        
        const killedCount = game.zombies.filter(z => z.health <= 0).length;
        game.zombies = game.zombies.filter(z => z.health > 0);
        
        setScore(prev => prev + killedCount * 10);
      };

      const createParticles = (x, y, color, count = 8) => {
        const game = gameRef.current;
        for (let i = 0; i < count; i++) {
          const angle = (Math.PI * 2 * i) / count;
          game.particles.push({
            x, y,
            vx: Math.cos(angle) * (2 + Math.random() * 2),
            vy: Math.sin(angle) * (2 + Math.random() * 2),
            life: 30,
            color
          });
        }
      };

      const gameLoop = () => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        
        const ctx = canvas.getContext('2d');
        const game = gameRef.current;
        const { width, height } = canvasSize;

        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(0, 0, width, height);

        // Grid
        ctx.strokeStyle = '#2a2a2a';
        ctx.lineWidth = 1;
        for (let i = 0; i < width; i += 40) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, height);
          ctx.stroke();
        }
        for (let i = 0; i < height; i += 40) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(width, i);
          ctx.stroke();
        }

        if (mouseDownRef.current) {
          shoot();
        }

        if (game.keys['w'] || game.keys['arrowup']) {
          game.player.y = Math.max(20, game.player.y - game.player.speed);
        }
        if (game.keys['s'] || game.keys['arrowdown']) {
          game.player.y = Math.min(height - 20, game.player.y + game.player.speed);
        }
        if (game.keys['a'] || game.keys['arrowleft']) {
          game.player.x = Math.max(20, game.player.x - game.player.speed);
        }
        if (game.keys['d'] || game.keys['arrowright']) {
          game.player.x = Math.min(width - 20, game.player.x + game.player.speed);
        }

        game.player.angle = Math.atan2(
          game.mousePos.y - game.player.y,
          game.mousePos.x - game.player.x
        );

        game.bullets = game.bullets.filter(bullet => {
          bullet.x += bullet.vx;
          bullet.y += bullet.vy;
          return bullet.x > 0 && bullet.x < width && bullet.y > 0 && bullet.y < height;
        });

        game.zombies.forEach(zombie => {
          const dx = game.player.x - zombie.x;
          const dy = game.player.y - zombie.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist > 0) {
            zombie.x += (dx / dist) * zombie.speed;
            zombie.y += (dy / dist) * zombie.speed;
          }

          zombie.walkCycle = (zombie.walkCycle || 0) + 0.15;

          if (dist < 30) {
            setHealth(prev => {
              const newHealth = Math.max(0, prev - 0.5);
              if (newHealth <= 0) {
                playSound('gameOver');
                setGameState('gameOver');
                setHighScore(prevHigh => Math.max(prevHigh, score));
              } else if (Math.random() < 0.1) {
                playSound('damage');
              }
              return newHealth;
            });
          }
        });

        game.bullets.forEach((bullet, bIndex) => {
          game.zombies.forEach((zombie, zIndex) => {
            const dx = bullet.x - zombie.x;
            const dy = bullet.y - zombie.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < 20) {
              zombie.health--;
              game.bullets.splice(bIndex, 1);
              playSound('hit');
              
              if (zombie.health <= 0) {
                createParticles(zombie.x, zombie.y, '#ef4444');
                createParticles(zombie.x, zombie.y, '#7f1d1d', 12);
                game.zombies.splice(zIndex, 1);
                setScore(prev => prev + 10);
                playSound('kill');
                
                if (Math.random() < 0.3) {
                  setAmmo(prev => prev + 5);
                  playSound('reload');
                }
              }
            }
          });
        });

        game.particles = game.particles.filter(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.98;
          p.vy *= 0.98;
          p.life--;
          return p.life > 0;
        });

        if (game.zombies.length === 0 && gameState === 'playing') {
          setWave(prev => {
            const newWave = prev + 1;
            spawnWave(newWave);
            setAmmo(prevAmmo => prevAmmo + 10);
            setSpecialCharges(prevCharges => Math.min(5, prevCharges + 1));
            playSound('wave');
            return newWave;
          });
        }

        // Draw blood particles
        game.particles.forEach(p => {
          ctx.fillStyle = p.color;
          ctx.globalAlpha = p.life / 30;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Draw zombies with realistic 2D sprites
        game.zombies.forEach(zombie => {
          ctx.save();
          ctx.translate(zombie.x, zombie.y);
          
          const angle = Math.atan2(game.player.y - zombie.y, game.player.x - zombie.x);
          const facingRight = Math.abs(angle) < Math.PI / 2;
          
          if (!facingRight) {
            ctx.scale(-1, 1);
          }

          // Body
          ctx.fillStyle = '#4a5568';
          ctx.fillRect(-12, -15, 24, 35);
          
          // Torn shirt
          ctx.fillStyle = '#2d3748';
          ctx.fillRect(-12, -15, 24, 20);
          ctx.fillStyle = '#1a202c';
          ctx.fillRect(-10, -10, 8, 3);
          ctx.fillRect(2, -10, 8, 3);
          
          // Legs with walking animation
          const legSwing = Math.sin(zombie.walkCycle) * 10;
          ctx.fillStyle = '#2d3748';
          ctx.fillRect(-8, 20, 7, 15 + legSwing);
          ctx.fillRect(1, 20, 7, 15 - legSwing);
          
          // Arms
          const armSwing = Math.sin(zombie.walkCycle + 1) * 8;
          ctx.fillStyle = '#6b7280';
          ctx.fillRect(-15, -5 + armSwing, 6, 20);
          ctx.fillRect(9, -5 - armSwing, 6, 20);
          
          // Head
          ctx.fillStyle = '#7c9885';
          ctx.beginPath();
          ctx.arc(0, -20, 10, 0, Math.PI * 2);
          ctx.fill();
          
          // Eyes (red)
          ctx.fillStyle = '#dc2626';
          ctx.beginPath();
          ctx.arc(-4, -22, 2, 0, Math.PI * 2);
          ctx.arc(4, -22, 2, 0, Math.PI * 2);
          ctx.fill();
          
          // Mouth (gaping)
          ctx.fillStyle = '#1a202c';
          ctx.beginPath();
          ctx.arc(0, -16, 3, 0, Math.PI);
          ctx.fill();
          
          // Blood drips
          ctx.fillStyle = '#7f1d1d';
          ctx.fillRect(-2, -13, 2, 5);
          ctx.fillRect(1, -11, 1, 3);
          
          // Scars
          ctx.strokeStyle = '#374151';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(-7, -18);
          ctx.lineTo(-3, -16);
          ctx.stroke();

          ctx.restore();

          // Health bar
          const healthPercent = zombie.health / zombie.maxHealth;
          ctx.fillStyle = '#1f2937';
          ctx.fillRect(zombie.x - 20, zombie.y - 45, 40, 5);
          ctx.fillStyle = '#dc2626';
          ctx.fillRect(zombie.x - 20, zombie.y - 45, 40 * healthPercent, 5);
          
          // Health bar border
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1;
          ctx.strokeRect(zombie.x - 20, zombie.y - 45, 40, 5);
        });

        // Draw bullets with glow
        game.bullets.forEach(bullet => {
          ctx.shadowBlur = 10;
          ctx.shadowColor = '#fbbf24';
          ctx.fillStyle = '#fbbf24';
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
          ctx.fill();
          
          // Bullet trail
          ctx.fillStyle = '#f59e0b';
          ctx.globalAlpha = 0.5;
          ctx.beginPath();
          ctx.arc(bullet.x - bullet.vx * 0.5, bullet.y - bullet.vy * 0.5, 3, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
          ctx.shadowBlur = 0;
        });

        // Draw player with realistic 2D sprite
        ctx.save();
        ctx.translate(game.player.x, game.player.y);
        ctx.rotate(game.player.angle);
        
        // Body (tactical vest)
        ctx.fillStyle = '#1e3a8a';
        ctx.fillRect(-15, -20, 30, 40);
        
        // Vest details
        ctx.fillStyle = '#1e40af';
        ctx.fillRect(-12, -15, 24, 30);
        ctx.fillStyle = '#2563eb';
        ctx.fillRect(-10, -10, 8, 5);
        ctx.fillRect(2, -10, 8, 5);
        
        // Belt
        ctx.fillStyle = '#374151';
        ctx.fillRect(-15, 10, 30, 4);
        ctx.fillStyle = '#fbbf24';
        ctx.fillRect(-2, 10, 4, 4);
        
        // Legs
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(-10, 20, 8, 15);
        ctx.fillRect(2, 20, 8, 15);
        
        // Boots
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(-10, 30, 8, 5);
        ctx.fillRect(2, 30, 8, 5);
        
        // Arms
        ctx.fillStyle = '#4b5563';
        ctx.fillRect(-18, -8, 6, 20);
        ctx.fillRect(12, -8, 6, 20);
        
        // Gun (detailed)
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(10, -5, 25, 8);
        ctx.fillStyle = '#374151';
        ctx.fillRect(10, -3, 25, 4);
        ctx.fillStyle = '#0f172a';
        ctx.fillRect(32, -4, 3, 6);
        
        // Gun barrel
        ctx.fillStyle = '#000';
        ctx.fillRect(35, -2, 8, 2);
        
        // Muzzle flash when shooting
        if (mouseDownRef.current && Date.now() - game.lastShot < 100) {
          ctx.fillStyle = '#fbbf24';
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          ctx.moveTo(43, 0);
          ctx.lineTo(50, -5);
          ctx.lineTo(50, 5);
          ctx.closePath();
          ctx.fill();
          ctx.globalAlpha = 1;
        }
        
        ctx.restore();
        
        // Draw head separately (always upright)
        ctx.save();
        ctx.translate(game.player.x, game.player.y);
        
        // Head
        ctx.fillStyle = '#fbbf24';
        ctx.beginPath();
        ctx.arc(0, -25, 12, 0, Math.PI * 2);
        ctx.fill();
        
        // Helmet
        ctx.fillStyle = '#1e3a8a';
        ctx.beginPath();
        ctx.arc(0, -27, 12, Math.PI, Math.PI * 2);
        ctx.fill();
        
        // Face mask
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(-8, -22, 16, 8);
        
        // Eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(-4, -20, 2, 0, Math.PI * 2);
        ctx.arc(4, -20, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupils
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.arc(-4, -20, 1, 0, Math.PI * 2);
        ctx.arc(4, -20, 1, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();

        // Crosshair with animation
        const crosshairSize = 12 + Math.sin(Date.now() * 0.005) * 2;
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 2;
        ctx.shadowBlur = 5;
        ctx.shadowColor = '#ef4444';
        ctx.beginPath();
        ctx.moveTo(game.mousePos.x - crosshairSize, game.mousePos.y);
        ctx.lineTo(game.mousePos.x + crosshairSize, game.mousePos.y);
        ctx.moveTo(game.mousePos.x, game.mousePos.y - crosshairSize);
        ctx.lineTo(game.mousePos.x, game.mousePos.y + crosshairSize);
        ctx.stroke();
        
        // Crosshair center dot
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        ctx.arc(game.mousePos.x, game.mousePos.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        game.animationFrame = requestAnimationFrame(gameLoop);
      };

      return React.createElement('div', {
        className: "min-h-screen bg-gradient-to-br from-gray-900 via-red-900 to-gray-900 flex items-center justify-center p-2 sm:p-4 game-content"
      },
        React.createElement('div', { className: "max-w-full w-full" },
          gameState === 'menu' && React.createElement('div', { className: "text-center space-y-4 sm:space-y-8 px-4" },
            React.createElement('div', { className: "space-y-2 sm:space-y-4" },
              React.createElement(Skull, { className: "w-16 h-16 sm:w-24 sm:h-24 mx-auto text-red-500" }),
              React.createElement('h1', { className: "text-3xl sm:text-4xl md:text-6xl font-bold text-white" }, "SOBREVIVÃŠNCIA ZUMBI"),
              React.createElement('p', { className: "text-base sm:text-xl text-gray-300" }, "Sobreviva Ã s ondas de zumbis!")
            ),
            React.createElement('div', { className: "bg-black/50 rounded-lg p-4 sm:p-6 text-left max-w-md mx-auto space-y-2 sm:space-y-3 text-gray-300 text-sm sm:text-base" },
              React.createElement('h2', { className: "text-2xl font-bold text-white mb-4" }, "Como Jogar:"),
              React.createElement('p', {}, React.createElement('strong', { className: "text-white" }, "WASD / Setas:"), " Mover"),
              React.createElement('p', {}, React.createElement('strong', { className: "text-white" }, "Mouse:"), " Mirar"),
              React.createElement('p', {}, React.createElement('strong', { className: "text-white" }, "Segurar Mouse:"), " Tiro automÃ¡tico"),
              React.createElement('p', {}, React.createElement('strong', { className: "text-cyan-400" }, "ESPAÃ‡O:"), " Habilidade Especial (explosÃ£o)"),
              React.createElement('p', { className: "text-sm text-yellow-400 mt-4" }, "ðŸ’¡ Zumbis soltam muniÃ§Ã£o aleatoriamente!"),
              React.createElement('p', { className: "text-sm text-cyan-400" }, "âš¡ Ganhe cargas especiais ao completar ondas!")
            ),
            highScore > 0 && React.createElement('div', { className: "flex items-center justify-center gap-2 text-yellow-400 text-xl" },
              React.createElement(Award, { className: "w-6 h-6" }),
              React.createElement('span', {}, `Recorde: ${highScore}`)
            ),
            React.createElement('button', {
              onClick: () => setGameState('playing'),
              className: "bg-red-600 hover:bg-red-700 text-white px-6 sm:px-12 py-3 sm:py-4 rounded-lg text-lg sm:text-2xl font-bold flex items-center gap-2 sm:gap-3 mx-auto transition-all transform hover:scale-105"
            },
              React.createElement(PlayCircle, { className: "w-6 h-6 sm:w-8 sm:h-8" }),
              "ComeÃ§ar Jogo"
            )
          ),
          
          gameState === 'playing' && React.createElement('div', { className: "space-y-2 sm:space-y-4 w-full" },
            React.createElement('div', { className: "bg-black/70 rounded-lg p-2 sm:p-4 flex flex-wrap justify-between items-center text-white gap-2" },
              React.createElement('div', { className: "flex items-center gap-1 sm:gap-2" },
                React.createElement(Heart, { className: "w-4 h-4 sm:w-6 sm:h-6 text-red-500" }),
                React.createElement('div', { className: "w-24 sm:w-48 bg-gray-700 rounded-full h-4 sm:h-6" },
                  React.createElement('div', {
                    className: "bg-red-500 h-4 sm:h-6 rounded-full transition-all",
                    style: { width: `${health}%` }
                  })
                ),
                React.createElement('span', { className: "font-bold text-sm sm:text-base" }, `${Math.round(health)}%`)
              ),
              React.createElement('div', { className: "flex items-center gap-2 sm:gap-4" },
                React.createElement('div', { className: "flex items-center gap-1 sm:gap-2" },
                  React.createElement(Target, { className: "w-4 h-4 sm:w-6 sm:h-6 text-yellow-500" }),
                  React.createElement('span', { className: "font-bold text-lg sm:text-2xl" }, ammo)
                ),
                React.createElement('div', { className: "flex items-center gap-1 sm:gap-2" },
                  React.createElement(Zap, { className: "w-4 h-4 sm:w-6 sm:h-6 text-cyan-400" }),
                  React.createElement('div', { className: "flex gap-1" },
                    [...Array(5)].map((_, i) =>
                      React.createElement('div', {
                        key: i,
                        className: `w-2 h-4 sm:w-3 sm:h-6 rounded ${i < specialCharges ? 'bg-cyan-400' : 'bg-gray-600'}`
                      })
                    )
                  )
                )
              ),
              React.createElement('div', { className: "flex items-center gap-2 sm:gap-4" },
                React.createElement('span', { className: "text-sm sm:text-xl" }, 
                  "Onda: ",
                  React.createElement('strong', { className: "text-red-400" }, wave)
                ),
                React.createElement('span', { className: "text-sm sm:text-xl" },
                  "Pontos: ",
                  React.createElement('strong', { className: "text-yellow-400" }, score)
                ),
                React.createElement('button', {
                  onClick: () => setSoundEnabled(!soundEnabled),
                  className: "p-1 sm:p-2 hover:bg-white/10 rounded-lg transition-colors"
                },
                  soundEnabled ? React.createElement(Volume2, { className: "w-4 h-4 sm:w-6 sm:h-6" }) : React.createElement(VolumeX, { className: "w-4 h-4 sm:w-6 sm:h-6" })
                )
              )
            ),
            React.createElement('canvas', {
              ref: canvasRef,
              width: canvasSize.width,
              height: canvasSize.height,
              className: "border-4 border-red-600 rounded-lg cursor-none",
              style: { 
                maxWidth: '100%',
                maxHeight: '100%',
                width: canvasSize.width + 'px',
                height: canvasSize.height + 'px'
              }
            }),
            React.createElement('div', { className: "text-center text-gray-400 text-sm space-y-1" },
              React.createElement('p', {}, "ðŸŽ¯ Sobreviva o mÃ¡ximo que puder! Cada onda fica mais difÃ­cil."),
              React.createElement('p', { className: "text-cyan-400" }, `âš¡ Pressione ESPAÃ‡O para usar a habilidade especial (${specialCharges} disponÃ­veis)`)
            )
          ),
          
          gameState === 'gameOver' && React.createElement('div', { className: "text-center space-y-8" },
            React.createElement('div', { className: "space-y-4" },
              React.createElement(Skull, { className: "w-24 h-24 mx-auto text-red-500 animate-pulse" }),
              React.createElement('h1', { className: "text-6xl font-bold text-white" }, "GAME OVER"),
              React.createElement('p', { className: "text-2xl text-red-400" }, "VocÃª foi derrotado!")
            ),
            React.createElement('div', { className: "bg-black/50 rounded-lg p-8 max-w-md mx-auto space-y-4" },
              React.createElement('div', { className: "flex justify-between text-xl text-white" },
                React.createElement('span', {}, "PontuaÃ§Ã£o Final:"),
                React.createElement('span', { className: "font-bold text-yellow-400" }, score)
              ),
              React.createElement('div', { className: "flex justify-between text-xl text-white" },
                React.createElement('span', {}, "Ondas Sobrevividas:"),
                React.createElement('span', { className: "font-bold text-red-400" }, wave - 1)
              ),
              score >= highScore && score > 0 && React.createElement('p', { className: "text-yellow-400 font-bold flex items-center justify-center gap-2" },
                React.createElement(Award, { className: "w-6 h-6" }),
                "NOVO RECORDE!"
              )
            ),
            React.createElement('div', { className: "flex gap-4 justify-center" },
              React.createElement('button', {
                onClick: () => setGameState('playing'),
                className: "bg-red-600 hover:bg-red-700 text-white px-8 py-4 rounded-lg text-xl font-bold flex items-center gap-2 transition-all transform hover:scale-105"
              },
                React.createElement(RotateCcw, { className: "w-6 h-6" }),
                "Jogar Novamente"
              ),
              React.createElement('button', {
                onClick: () => setGameState('menu'),
                className: "bg-gray-700 hover:bg-gray-600 text-white px-8 py-4 rounded-lg text-xl font-bold transition-all"
              },
                "Menu"
              )
            )
          )
        )
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(ZombieSurvivalGame));
  </script>
</body>
</html>
